#include "textbox.h"

int32_t CStatsText::generate(ENVIRONMENT * env)
{
  int32_t result = EXIT_SUCCESS;
  char chText[256];
  char chSeqZ[40];
  char chSeqW[40];

  memset (chText, 0, 256);
  memset (chSeqZ, 0,  40);
  memset (chSeqW, 0,  40);

  /// Step one: Generate the text content
  txtContent[0].SetText(chText);

  if (env->withBump)
    pwx_snprintf(chText, 255, " Texture %08d (with Bumpmap)", env->imageNum);
  else
    pwx_snprintf(chText, 255, " Texture %08d (no Bumpmap)", env->imageNum);
  txtContent[1].SetText(chText);
  pwx_snprintf(chText, 255, " Seed : %d, Dimensions : %d", env->seed, env->dimensions);
  txtContent[2].SetText(chText);
  pwx_snprintf(chText, 255, " Offset X : %g", env->offX);
  txtContent[3].SetText(chText);
  pwx_snprintf(chText, 255, " Offset Y : %g", env->offY);
  txtContent[4].SetText(chText);

  if (env->dimensions >= 3)
    {
      pwx_snprintf(chText, 255, " Offset Z : %g (mod Z : %g)", env->offZ, env->modZ);
      showSeqPat(env, chSeqZ, chSeqW);
    }
  else
    memset (chText, 0, 256);
  txtContent[5].SetText(chText);
  txtContent[6].SetText("");

  if (env->dimensions >= 4)
    pwx_snprintf(chText, 255, " Offset W : %g (mod W : %g)", env->offW, env->modW);
  else
    memset (chText, 0, 256);
  txtContent[7].SetText(chText);
  txtContent[8].SetText("");

  pwx_snprintf(chText, 255, " Interval: %g -> %g", env->borderLo, env->borderHi);
  txtContent[9].SetText(chText);


  if (env->spxWave > 1)
    pwx_snprintf(chText, 255, " Waves %d with reduction %g", env->spxWave, env->spxRedu);
  else
    memset (chText, 0, 256);
  txtContent[10].SetText(chText);

  pwx_snprintf(chText, 255, " Zoom %g, Smoothing: %g", env->spxZoom, env->spxSmoo);
  txtContent[11].SetText(chText);

  memset (chText, 0, 256);
  txtContent[12].SetText(chText);

  /// Step two: set background image
  uint32_t txtWidth = 0;
  uint32_t txtTop   = env->scrHeight;
  uint32_t txtBottom= 0;
  for (int32_t i = 0; i < txtSize; ++i)
    {
      sf::FloatRect txtRect = txtContent[i].GetRect();
      txtWidth   = std::max(txtWidth, static_cast<uint32_t>(pwx_round(txtRect.GetWidth())));
      txtTop     = std::min(txtTop,   static_cast<uint32_t>(pwx_round(txtRect.Top)));
      txtBottom  = std::max(txtBottom,static_cast<uint32_t>(pwx_round(txtRect.Bottom)));
    }

  try
    {
      if (txtBox)
        delete (txtBox);
      txtBox = new sf::Image(txtWidth + 10, txtBottom - txtTop + 10, bgColor);
    }
  catch (std::bad_alloc &e)
    {
      cerr << "ERROR  : Can't create background sprite for the stats text!" << endl;
      cerr << "Reason : \"" << e.what() << "\"" << endl;
      result = EXIT_FAILURE;
    }


  return (result);
}


int32_t CStatsText::initialize(ENVIRONMENT * env)
{
  int32_t result = EXIT_SUCCESS;

  /// Step one: set colors:
  uint8_t redMin = std::max(env->colHi.r, std::max(env->colMid.r, env->colLow.r  ) );
  uint8_t greMin = std::max(env->colHi.g, std::max(env->colMid.g, env->colLow.g) );
  uint8_t bluMin = std::max(env->colHi.b, std::max(env->colMid.b, env->colLow.b ) );
  uint8_t redMax = std::min(env->colHi.r, std::min(env->colMid.r, env->colLow.r  ) );
  uint8_t greMax = std::min(env->colHi.g, std::min(env->colMid.g, env->colLow.g) );
  uint8_t bluMax = std::min(env->colHi.b, std::min(env->colMid.b, env->colLow.b ) );
  // Set the foreground text color:
  txtColor.r = redMin;
  txtColor.g = greMin;
  txtColor.b = bluMin;
  // Set the Background color:
  bgColor.r  =redMax;
  bgColor.g  =greMax;
  bgColor.b  =bluMax;

  /// Step two: Set size and allocate memory:
  txtSize = 13;
  try
    {
      txtContent = new sf::String[txtSize];
      for (int32_t i = 0; i < txtSize; ++i)
        {
          txtContent[i].SetColor(txtColor);
          txtContent[i].SetFont(*(env->font));
          txtContent[i].SetPosition(10.f, 10.f + (i * 15));
          txtContent[i].SetSize(env->fontSize);
          txtContent[i].SetText("");
        }
    }
  catch (std::bad_alloc &e)
    {
      cerr << "ERROR  : Can't create " << txtSize << " strings for status text!" << endl;
      cerr << "Reason : \"" << e.what() << "\"" << endl;
      result = EXIT_FAILURE;
    }

  // no set text, texts are generated by generate()
  // the same applies for the background image, as we have no dimensions yet.

  return (result);
}


int32_t CHelpText::generate(ENVIRONMENT * env)
{
  int32_t result = EXIT_SUCCESS;

  /// step one: Generate Text:
  int32_t i = 0;
  txtContent[i++].SetText      ("                                                                ");
  txtContent[i++].SetText      (" Key Mappings :                                                 ");
  txtContent[i++].SetText      (" -------------------------------------------------------------- ");
  txtContent[i++].SetText      (" CURSOR: modify x with left/right, y with up/down cursor keys   ");
  txtContent[i++].SetText      ("       : left/down decreases, right/up increases. (default 1.0) ");
  txtContent[i++].SetText      ("         press ctrl to increase/decrease with 10 times mod x/y. ");
  txtContent[i++].SetText      (" d/D   : increase/decrease dimensions (2-4)                     ");
  txtContent[i++].SetText      (" ESC   : Quit program                                           ");
  txtContent[i++].SetText      (" h     : Show this help                                         ");
  txtContent[i++].SetText      (" R     : Render image with current settings                     ");
  if (env->withBump)
    {
      txtContent[i++].SetText  (" s     : Save current texture and bumpmap                       ");
      txtContent[i++].SetText  (" SPACE : Toggle between texture and bumpmap                     ");
    }
  else
    {
      txtContent[i++].SetText  (" s     : Save current texture                                   ");
      txtContent[i++].SetText  ("                                                                ");
    }
  txtContent[i++].SetText      (" TAB   : Show stats of the current image                        ");
  if (env->dimensions >= 4)
    {
      txtContent[i++].SetText  (" w/W   : increase/decrease offset w by mod w. (defaults to 1.0) ");
      txtContent[i++].SetText  ("         press ctrl to increase/decrease with 10 times mod w.   ");
      txtContent[i++].SetText  ("         press alt to toggle w coordinate sequence pattern.     ");
    }
  else
    {
      txtContent[i++].SetText  ("                                                                ");
      txtContent[i++].SetText  ("                                                                ");
      txtContent[i++].SetText  ("                                                                ");
    }
  if (env->dimensions >= 3)
    {
      txtContent[i++].SetText  (" z/Z   : increase/decrease offset z by mod z. (defaults to 1.0) ");
      txtContent[i++].SetText  ("         press ctrl to increase/decrease with 10 times mod z.   ");
      txtContent[i++].SetText  ("         press alt to toggle z coordinate sequence pattern.     ");
    }
  else
    {
      txtContent[i++].SetText  ("                                                                ");
      txtContent[i++].SetText  ("                                                                ");
      txtContent[i++].SetText  ("                                                                ");
    }
  txtContent[i++].SetText      ("                                                                ");

  assert(i == txtSize);

  /// Step two: get text width and height:
  uint32_t txtWidth = 0;
  uint32_t txtTop   = env->scrHeight;
  uint32_t txtBottom= 0;
  for (i = 0; i < txtSize; ++i)
    {
      sf::FloatRect txtRect = txtContent[i].GetRect();
      txtWidth   = std::max(txtWidth, static_cast<uint32_t>(pwx_round(txtRect.GetWidth())));
      txtTop     = std::min(txtTop,   static_cast<uint32_t>(pwx_round(txtRect.Top)));
      txtBottom  = std::max(txtBottom,static_cast<uint32_t>(pwx_round(txtRect.Bottom)));
    }

  /// Step three: Generate Background image:
  try
    {
      if (txtBox)
        delete txtBox;
      txtBox = new sf::Image(txtWidth + 10, txtBottom - txtTop + 10, bgColor);
    }
  catch (std::bad_alloc &e)
    {
      cerr << "ERROR  : Can't create background image for the help text!" << endl;
      cerr << "Reason : \"" << e.what() << "\"" << endl;
      result = EXIT_FAILURE;
    }

  return (result);
}


int32_t CHelpText::initialize(ENVIRONMENT * env)
{
  int32_t result = EXIT_SUCCESS;

  /// Step one: set colors:
  uint8_t redMin = std::max(env->colHi.r, std::max(env->colMid.r, env->colLow.r  ) );
  uint8_t greMin = std::max(env->colHi.g, std::max(env->colMid.g, env->colLow.g) );
  uint8_t bluMin = std::max(env->colHi.b, std::max(env->colMid.b, env->colLow.b ) );
  uint8_t redMax = std::min(env->colHi.r, std::min(env->colMid.r, env->colLow.r  ) );
  uint8_t greMax = std::min(env->colHi.g, std::min(env->colMid.g, env->colLow.g) );
  uint8_t bluMax = std::min(env->colHi.b, std::min(env->colMid.b, env->colLow.b ) );
  // Set the foreground text color:
  txtColor.r = redMax;
  txtColor.g = greMax;
  txtColor.b = bluMax;
  // Set the Background color:
  bgColor.r  =redMin;
  bgColor.g  =greMin;
  bgColor.b  =bluMin;

  /// Step two: Set size and allocate memory:
  txtSize = 20;
  try
    {
      txtContent = new sf::String[txtSize];
      for (int32_t i = 0; i < txtSize; ++i)
        {
          txtContent[i].SetColor(txtColor);
          txtContent[i].SetFont(*(env->font));
          txtContent[i].SetPosition(10.f, 10.f + (i * 15));
          txtContent[i].SetSize(env->fontSize);
          txtContent[i].SetText("");
        }
    }
  catch (std::bad_alloc &e)
    {
      cerr << "ERROR  : Can't create " << txtSize << " strings for help text!" << endl;
      cerr << "Reason : \"" << e.what() << "\"" << endl;
      result = EXIT_FAILURE;
    }

  // The background image is calcualted by generate().

  return (result);
}


/** @brief ~CTextBox
  *
  * default dtor, frees resources.
  */
CTextBox::~CTextBox()
{
  // free created text surface if appropriate
  if (txtContent)
    delete [] txtContent;
  txtContent = NULL;

  // delete text box image
  if (txtBox)
    delete txtBox;
  txtBox = NULL;
}

/** @brief CTextBox
  *
  * default constructor, nothing special
  */
CTextBox::CTextBox():
  bgColor(200, 160, 120),txtColor(0, 0, 0),
  txtBox(NULL),txtSize(0),txtContent(NULL)
{
  /* Nothing to be done here... */
}
